%\VignetteEngine{knitr::knitr_notangle}
%\VignetteIndexEntry{Guide for using ISOpureR}

\documentclass{article}
\usepackage{graphicx}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{amsmath}
\usepackage{url}
\usepackage{color}
\usepackage{tikz}
\usepackage{float}
%\usetikzlibrary{bayesnet}
%\usetikzlibrary{arrows,shapes,calc}
\usepackage[unicode=true,pdfusetitle,
bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
{hyperref}
\hypersetup{
pdfstartview={XYZ null null 1}}

\begin{document}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@


<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@
\title{A guide to using \emph{iSubGen}}
\author{Natalie S. Fox}
\maketitle

\tableofcontents

%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}

The purpose of integrative subtype generation (iSubGen) is to provide a framework to discover subtypes 
based on the relationships between molecular aberration profiles without filtering
to known genes or relationships. ISubGen performs pattern discovery on a combination of
two types of compressed features. 
First, we use a collection of reduced features to allow emphasis of obvious patterns in the individual aberration types. 
The reduced features could be a small number of compressed features from autoencoders or the top principle components or even a handful of selected importnant characteristics of the profiles.
The second type of compressed feature is pairwise comparion of the aberration types.
This will allow patient classification based on whether the same relationships are observed in the different aberration types.
Here we will describe using correlations to compare the distances between patient profiles, but any similarity measure could be substituted.

\begin{figure}[H]
	\centering
		\includegraphics[width = \textwidth]{Figures/iSubGen_figure_methodology_overview.pdf}
		\caption{\textbf{iSubGen overview.}}
		\label{fig:isopure}
\end{figure}

\newpage
\subsection{Applying {\emph{iSubGen}} to a small example}
\label{small-example}

We will show how to use \emph{iSubGen} with a small example dataset. 
The example has has copy number (CNA) profiles, methylation profiles and coding single nucleotide variant (SNV) data for 30 patients.
The CNA data is gene based with -1 for a deletion, 0 for neutral and 1 for a gain.
The methylation data is probe based and is continuous values between -1 and 1.
The coding SNV data is gene based with 0 if there is no SNVs in the gene and 1 if there is 1 or more SNV(s) in the gene. 

\subsection{Load and format data}

The first step is to load the data. Here the genomic features are rows and patients are columns.  

<<load-data>>=
# Load the library and the data included with the package
library(iSubGen);
path.to.data <- '~/iSubGen/inst/exdata/';
molecular.data <- list();
for(i in c('cna','methy','csnvs')) {
  molecular.data[[i]] <- load.molecular.aberration.data(
    paste0(path.to.data,i,'_profiles.txt'),
    patients=c(paste0('EP00',1:9),paste0('EP0',10:30))
  );
}

# Check what the data looks like
str(molecular.data);
molecular.data$methy[1:5,1:5];
molecular.data$csnvs[1:5,1:5];
@


\section{Feature reduction}

\subsection{Autoencoders}

To be able to emphasize the main patterns in the individual aberration profies, 
we reduced features that should capture the overarching patterns of each aberration type.
In this case, we use autoencoders to reduce the features to a handful of compressed features representing the main patterns of each aberration type.
Autoencoders are beneficial because they can capture non-linear relationships.

\begin{figure}[H]
	\centering
		\includegraphics[width=10cm]{Figures/iSubGen_figure_methodolody_autoencoders.pdf}
		\caption{\textbf{iSubGen overview.}}
		\label{fig:isopure}
\end{figure}

\newpage
\subsection{Create the compressed autoencoder features}

We create autoencoders individually for each aberration type.
The create.autoencoder function is a wrapper function to create an autoencoder using the keras package.

<<ae-matrix>>=
# Create a list to store the autoencoders
autoencoders <- list();

# Create and train an autoencoder using CNA data
autoencoders[['cna']] <- create.autoencoder(
  aberration.type = 'cna',
  aberration.matrix = molecular.data$cna,
  encoder.layers.node.nums = c(20,2)
)$autoencoder;

# Create and train an autoencoder using methylation data
autoencoders[['methy']] <- create.autoencoder(
  aberration.type = 'methy',
  aberration.matrix = molecular.data$methy,
  encoder.layers.node.nums = c(15,1)
)$autoencoder;

# Create and train an autoencoder using coding SNV data
autoencoders[['csnvs']] <- create.autoencoder(
  aberration.type = 'csnvs',
  aberration.matrix = molecular.data$csnvs,
  encoder.layers.node.nums = c(15,1)
)$autoencoder;

# Get the compressed features from the autoencoders
compressed.feature.matrix <- create.compressed.autoencoder.feature.matrix(
  aberration.types = names(molecular.data),
  aberration.matrices = molecular.data,
  autoencoders = autoencoders
);

# Check what the data looks like
str(compressed.feature.matrix);
@

\newpage
\section{Pairwise similarity Matrix}

\subsection{Corrlation Matrix}

Importantly, iSubGen assesses variation between aberration types.
The correlation matrix is created by first creating the distance matrix for each aberration type.
This is the standard first steps for clustering based on a single aberration type.
However instead of clustering each distance matrix, the distances from a single patient to the other patients is correlated between aberration types.
This provides an assessment of how similar the relationships between patients are in the different aberration types 
and might elucidate whether there is different biological regulation subgroups of the cancers.

\begin{figure}[H]
	\centering
		\includegraphics[width=10cm]{Figures/iSubGen_figure_methodolody_correlations.pdf}
		\caption{\textbf{iSubGen overview.}}
		\label{fig:isopure}
\end{figure}

\subsection{Create the correlation matrix}

<<corrlation-matrix>>=
# Calculate the correlation matrix
corr.matrix <- calculate.integrative.correlation.matrix(
  aberration.types=names(molecular.data),
  aberration.matrices=molecular.data,
  aberration.metrics=list(
    cna='euclidean',
    csnvs='euclidean',
    methy='euclidean'
  )
);

# Check what the data looks like
str(corr.matrix);
@

\section{Combine features and create integrative subtypes}

\subsection{Combine integrative features}

Depending on where you want the emphasis for your subtype discovery, features may need to be reweighted when combined into one matrix. 
There may also need to be rescaling performed if the feature reduction and pairwise similarity return features which are not in similar spaces.
Here we use tanh on our activation function for the autoencoders so that our compressed autoencoder features are in -1 to 1 range. 
Similarly, correlations return values in the -1 to 1 range.

<<integrative-matrix>>=
# Combine autoencoder compressed features and the correlation matrix into one matrix
integrative.features.matrix <- combine.compressed.features(
  compressed.feature.matrix,
  corr.matrix
)$compressed.feature.matrix;

# Check what the data looks like
str(integrative.features.matrix);
head(integrative.features.matrix);
@

\subsection{Find patterns in integrative features}

Finally, pattern discovery must be performed on the integrative feature matrix to determine cancer subtypes. 
In this example, we use consensus clustering which iteratively runs hierarchically clustering.

<<cluster>>=
# Perform consensus clustering to get integrative subtypes
subtyping.results <- subtype.by.h.clustering(
  aberration.matrix=integrative.features.matrix,
  distance.metric='euclidean',
  parent.output.dir='./',
  new.result.dir='vignettes_subtypes',
  max.num.subtypes=5,
  clustering.reps=50,
  consensus.cluster.write.table=FALSE
  );

# Check subtyping results
str(subtyping.results$subtype_table);
head(subtyping.results$subtype_table);
@

\end{document}
