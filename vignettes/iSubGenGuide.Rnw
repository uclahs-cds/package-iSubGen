%\VignetteEngine{knitr::knitr_notangle}
%\VignetteIndexEntry{Guide for using ISOpureR}

\documentclass{article}
\usepackage{graphicx}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{amsmath}
\usepackage{url}
\usepackage{color}
\usepackage{tikz}
\usepackage{float}
%\usetikzlibrary{bayesnet}
%\usetikzlibrary{arrows,shapes,calc}
\usepackage[unicode=true,pdfusetitle,
bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
{hyperref}
\hypersetup{
pdfstartview={XYZ null null 1}}

\begin{document}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@


<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@
\title{A guide to using \emph{iSubGen}}
\author{Natalie S. Fox}
\maketitle

\tableofcontents

%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}

The purpose of integrative subtype generation (iSubGen) is to discover subtypes 
based on the relationships between molecular aberration profiles without filtering
to known genes or relationships.

\begin{figure}[H]
	\centering
		\includegraphics[width = \textwidth]{Figures/iSubGen_figure_methodology_overview.pdf}
		\caption{\textbf{iSubGen overview.}}
		\label{fig:isopure}
\end{figure}

\subsection{Applying {\emph{iSubGen}} to a small example}
\label{small-example}

We will show how to use \emph{iSubGen} with a small example dataset. 
The example has has copy number (CNA) profiles, methylation profiles and coding single nucleotide variant (SNV) data for 30 patients.
The CNA data is gene based with -1 for a deletion, 0 for neutral and 1 for a gain.
The methylation data is probe based and is continuous values between -1 and 1.
The coding SNV data is gene based wit 0 if there is no SNVs in the gene and 1 if there is 1 or more SNV(s) in the gene. 

\subsection{Load and format data}

The first step is to load the data. Here the genomic features are rows and patients are columns.  

<<load-data>>=
# Load the library and the data included with the package
library(iSubGen);
path.to.data <- '~/iSubGen/inst/exdata/';
molecular.data <- list();
for(i in c('cna','methy','csnvs')) {
  molecular.data[[i]] <- load.molecular.aberration.data(
    paste0(path.to.data,i,'_profiles.txt'),
    patients=c(paste0('EP00',1:9),paste0('EP0',10:30))
  );
}

# Check what the data looks like
str(molecular.data);
head(molecular.data$cna);
head(molecular.data$methy);
head(molecular.data$csnvs);
@

\section{Feature reduction}

\subsection{Autoencoders}

\begin{figure}[H]
	\centering
		\includegraphics[width=10cm]{Figures/iSubGen_figure_methodolody_autoencoders.pdf}
		\caption{\textbf{iSubGen overview.}}
		\label{fig:isopure}
\end{figure}

\subsection{Create the compressed autoencoder features}

<<ae-matrix>>=
# Create a list to store the autoencoders
autoencoders <- list();

# Create and train an autoencoder using CNA data
autoencoders[['cna']] <- create.autoencoder(
  aberration.type = 'cna',
  aberration.matrix = molecular.data$cna,
  encoder.layers.node.nums = c(20,2)
)$autoencoder;

# Create and train an autoencoder using methylation data
autoencoders[['methy']] <- create.autoencoder(
  aberration.type = 'methy',
  aberration.matrix = molecular.data$methy,
  encoder.layers.node.nums = c(15,1)
)$autoencoder;

# Create and train an autoencoder using coding SNV data
autoencoders[['csnvs']] <- create.autoencoder(
  aberration.type = 'csnvs',
  aberration.matrix = molecular.data$csnvs,
  encoder.layers.node.nums = c(15,1)
)$autoencoder;

# Get the compressed features from the autoencoders
compressed.feature.matrix <- create.compressed.autoencoder.feature.matrix(
  aberration.types = names(molecular.data),
  aberration.matrices = molecular.data,
  autoencoders = autoencoders
);

# Check what the data looks like
str(compressed.feature.matrix);
@

\section{Similarity Matrix}

\subsection{Corrlation Matrix}

\begin{figure}[H]
	\centering
		\includegraphics[width=10cm]{Figures/iSubGen_figure_methodolody_correlations.pdf}
		\caption{\textbf{iSubGen overview.}}
		\label{fig:isopure}
\end{figure}

\subsection{Create the correlation matrix}

<<corrlation-matrix>>=
# Calculate the correlation matrix
corr.matrix <- calculate.integrative.correlation.matrix(
  aberration.types=names(molecular.data),
  aberration.matrices=molecular.data,
  aberration.metrics=list(
    cna='euclidean',
    csnvs='euclidean',
    methy='euclidean'
  )
);

# Check what the data looks like
str(corr.matrix);
@

\section{Combine features and create integrative subtypes}

\subsection{Combine integrative features}

<<integrative-matrix>>=
# Combine autoencoder compressed features and the correlation matrix into one matrix
integrative.features.matrix <- combine.compressed.features(
  compressed.feature.matrix,
  corr.matrix
)$compressed.feature.matrix;

# Check what the data looks like
str(integrative.features.matrix);
head(integrative.features.matrix);
@

\subsection{Find patterns in integrative features}

<<cluster>>=
# Perform consensus clustering to get integrative subtypes
subtyping.results <- subtype.by.h.clustering(
  aberration.matrix=integrative.features.matrix,
  distance.metric='euclidean',
  parent.output.dir='./',
  new.result.dir='vignettes_subtypes',
  max.num.subtypes=5,
  clustering.reps=50,
  consensus.cluster.write.table=FALSE
  );

# Check subtyping results
str(subtyping.results$subtype_table);
head(subtyping.results$subtype_table);
@

\end{document}
