%\VignetteEngine{knitr::knitr_notangle}
%\VignetteIndexEntry{Guide for using ISOpureR}

\documentclass{article}
\usepackage{graphicx}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{amsmath}
\usepackage{url}
\usepackage{color}
\usepackage{tikz}
\usepackage{float}
%\usetikzlibrary{bayesnet}
%\usetikzlibrary{arrows,shapes,calc}
\usepackage[unicode=true,pdfusetitle,
bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
{hyperref}
\hypersetup{
pdfstartview={XYZ null null 1}}

\begin{document}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@


<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@
\title{A guide to using \emph{iSubGen}}
\author{Natalie S. Fox}
\maketitle

\tableofcontents

%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}

The purpose of integrative subtype generation (iSubGen) is to provide a framework for subtype discovery 
based on the relationships between molecular aberration profiles (ex. mRNA, single nucleotide variants, copy number alterations, etc)
without filtering to known genes or relationships.
ISubGen performs pattern discovery on a combination of two types of compressed features. 
First, we use a collection of reduced features to allow emphasis of obvious patterns in the individual aberration types. 
The reduced features could be a small number of compressed features from autoencoders or the top principle components or even a handful of selected important characteristics of the profiles.
The second type of compressed feature is pairwise comparison of the aberration types.
This will allow patient classification based on whether the same relationships are observed in the different aberration types.

\begin{figure}[H]
	\centering
		\includegraphics[width = \textwidth]{Figures/iSubGen_figure_methodology_overview.pdf}
		\caption{\textbf{iSubGen overview. Compressed features from feature reduction and pairwise similarity measures are merged into a single matrix for pattern discovery.}}
		\label{fig:isopure}
\end{figure}

\newpage
\subsection{Applying {\emph{iSubGen}} to an example}
\label{small-example}

We will show how to use \emph{iSubGen} with a small example dataset. 
The example has has copy number (CNA) profiles, methylation profiles and coding single nucleotide variant (SNV) data for 30 patients.
The CNA data is gene based with -1 for a deletion, 0 for neutral and 1 for a gain.
The methylation data is probe based and is continuous values between -1 and 1.
The coding SNV data is gene based with 0 if there is no SNVs in the gene and 1 if there is 1 or more SNV(s) in the gene. 

\subsection{Load and format data}

The first step is to load the data. Here the genomic features are rows and patients are columns.  

<<load-data>>=
# Load the library and the data included with the package
library(iSubGen);
path.to.data <- '~/iSubGen/inst/exdata/';
molecular.data <- list();
for(i in c('cna','methy','csnvs')) {
  molecular.data[[i]] <- load.molecular.aberration.data(
    paste0(path.to.data,i,'_profiles.txt'),
    patients=c(paste0('EP00',1:9),paste0('EP0',10:30))
  );
}

# Check what the data looks like
str(molecular.data);
molecular.data$methy[1:5,1:5];
molecular.data$csnvs[1:5,1:5];
@


\section{Feature reduction}

\subsection{Autoencoders}


To be able to emphasize the main patterns in the individual aberration profiles, 
we compressed features to a smaller set of features that capture the overarching patterns of each aberration type.
In this case, we use autoencoders to reduce the features to a handful of compressed features representing the main patterns of each aberration type. \\


An autoencoder is a neural net which is trained to output the input it was given. 
The number of nodes will decrease in the first layers to "encode" the data 
and then the number of nodes will increase in the following layers to "decode" the data.
In this way if we take the values from the smallest number of nodes at the interface of the encoding and decoding layers, 
all the data of the input features should be represented in a smaller number of features.
A benefit of using autoencoders for compressing features is that autoencoders can capture non-linear relationships.

\begin{figure}[H]
	\centering
		\includegraphics[width=9.8cm]{Figures/iSubGen_figure_methodolody_autoencoders.pdf}
		\caption{\textbf{Schematic for iSubGen feature reduction using autoencoders.}}
		\label{fig:isopure}
\end{figure}

\newpage
\subsection{Create the compressed autoencoder features}

We create autoencoders individually for each aberration type.
The create.autoencoder function is a wrapper function to create an autoencoder using the \href{https://cran.r-project.org/package=keras}{keras} package.

<<ae-matrix>>=
# Create a list to store the autoencoders
autoencoders <- list();

# Create and train an autoencoder using CNA data
autoencoders[['cna']] <- create.autoencoder(
  aberration.type = 'cna',
  aberration.matrix = molecular.data$cna,
  encoder.layers.node.nums = c(20,2)
)$autoencoder;
# take a look at the layers/number of nodes in the autoencoder
str(autoencoders$cna);

# Create and train an autoencoder using methylation data
autoencoders[['methy']] <- create.autoencoder(
  aberration.type = 'methy',
  aberration.matrix = molecular.data$methy,
  encoder.layers.node.nums = c(15,1)
)$autoencoder;
# take a look at the layers/number of nodes in the autoencoder
str(autoencoders$methy);

# Create and train an autoencoder using coding SNV data
autoencoders[['csnvs']] <- create.autoencoder(
  aberration.type = 'csnvs',
  aberration.matrix = molecular.data$csnvs,
  encoder.layers.node.nums = c(15,1)
)$autoencoder;
# take a look at the layers/number of nodes in the autoencoder
str(autoencoders$csnvs);

# Get the compressed features from the autoencoders
compressed.feature.matrix <- create.compressed.autoencoder.feature.matrix(
  aberration.types = names(molecular.data),
  aberration.matrices = molecular.data,
  autoencoders = autoencoders
);

# Check what the data looks like
str(compressed.feature.matrix);
@


\section{Pairwise similarity matrix}

In this example, we describe using correlations to compare the distances between patient profiles, but any similarity measure could be substituted. 

\subsection{Correlation matrix}

Importantly, iSubGen assesses variation between aberration types.
The correlation matrix is created by first creating the distance matrix for each aberration type.
This is the standard first steps for clustering based on a single aberration type.
However, instead of clustering each distance matrix, the distances from a single patient to the other patients is correlated between aberration types.
This provides an assessment of how similar the relationships between patients are in the different aberration types 
and might elucidate whether there are different biological regulation subgroups of the cancers.

\begin{figure}[H]
	\centering
		\includegraphics[width=9.8cm]{Figures/iSubGen_figure_methodolody_correlations.pdf}
		\caption{\textbf{Schematic for creating iSubGen pairwise similarity measures.}}
		\label{fig:isopure}
\end{figure}

\newpage
\subsection{Create the correlation matrix}

<<correlation-matrix>>=
# Calculate the correlation matrix
corr.matrix <- calculate.integrative.correlation.matrix(
  aberration.types=names(molecular.data),
  aberration.matrices=molecular.data,
  dist.metrics=list(
    cna='euclidean',
    csnvs='euclidean',
    methy='euclidean'
  )
);

# Check what the data looks like
str(corr.matrix);
@

\subsection{Consensus correlation matrix}

A correlation matrix or a consensus correlation matrix can be used the same.
A consensus correlation matrix simply includes resampling of the samples while creating the correlation matrix.

<<consensus-correlation-matrix>>=
# Calculate the correlation matrix
consensus.corr.matrix <- calculate.consensus.integrative.correlation.matrix(
  aberration.types=names(molecular.data),
  aberration.matrices=molecular.data,
  dist.metrics=list(
    cna='euclidean',
    csnvs='euclidean',
    methy='euclidean'
  )
);

# Check what the data looks like
str(consensus.corr.matrix);
@


\section{Combine features and create integrative subtypes}

\subsection{Combine integrative features}

Depending on where you want the emphasis for your subtype discovery, features may need to be reweighted when combined into one matrix. 
There may also need to be rescaling performed if the feature reduction and pairwise similarity return features which are not in similar spaces.
Here we use tanh on our activation function for the autoencoders so that our compressed autoencoder features are in -1 to 1 range. 
Similarly, correlations return values in the -1 to 1 range. We use Spearman's correlations.

<<integrative-matrix>>=
# Combine autoencoder compressed features and the correlation matrix into one matrix
integrative.features.matrix <- combine.compressed.features(
  compressed.feature.matrix,
  corr.matrix
)$compressed.feature.matrix;

# Check what the data looks like
str(integrative.features.matrix);
head(integrative.features.matrix);
@

\subsection{Find patterns in integrative features}

Finally, pattern discovery must be performed on the integrative feature matrix to determine cancer subtypes. 
In this example, we use \href{https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html}{consensus clustering} which iteratively runs hierarchically clustering.

<<cluster>>=
# Perform consensus clustering to get integrative subtypes
subtyping.results <- subtype.by.h.clustering(
  aberration.matrix=integrative.features.matrix,
  distance.metric='euclidean',
  parent.output.dir='./',
  new.result.dir='vignettes_subtypes',
  max.num.subtypes=5,
  clustering.reps=50,
  consensus.cluster.write.table=FALSE
  );

# Check subtyping results
str(subtyping.results$subtype_table);
head(subtyping.results$subtype_table);
@

\section{Glossary/Acronyms}

\noindent \textbf{Activation function:} defines the output of neural network nodes. \\

\noindent \textbf{Autoencoder:} an unsupervised approach for neural networks where the neural network tries to reconstruct its input. \\

\noindent \textbf{CNA:} copy number alteration. A change in the number of copies of a segment of DNA. 
Generally, humans have 2 copies of each gene; one from their mother and one from their father. 
In cancer, DNA segments can be duplicated so there are more than 2 copies or 
DNA segments can be deleted so there are less than 2 copies. \\

\noindent \textbf{Consensus clustering:} a process of iteratively clustering to essentially bootstrap the clustering result. \url{https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html} \\

\noindent \textbf{iSubGen:} integrative subtype generation.\\

\noindent \textbf{Keras R package:} \url{https://cran.r-project.org/package=keras} \\ 

\noindent \textbf{Methylation:} a DNA modification where methyl groups of are added to cytosines in DNA to help regulate DNA transcription. \\

\noindent \textbf{Molecular aberration type (or aberration type):} encapsulates the different changes that occur the DNA, RNA and other biomolecules during cancer. For example: CNAs, SNVs, methylation, mRNA abundance, miRNA abundance.\\

\noindent \textbf{SNV:} single nucleotide variant. a nucleotide base (A,C,G,T) change in DNA.\\

\end{document}
